import { SettingsViewModel } from '../viewmodel/SettingsViewModel';
import { TodayScheduleViewModel, TodayCourseResponse } from '../viewmodel/TodayScheduleViewModel';
import { WeeklyCourseViewModel } from '../viewmodel/WeeklyCourseViewModel';
import { Index } from './Index';
import { TodaySchedule } from './TodaySchedule';
import { Settings } from './Settings';
import { notificationManager } from '@kit.NotificationKit';
import { BusinessError } from '@kit.BasicServicesKit';
import abilityAccessCtrl, { Permissions } from '@ohos.abilityAccessCtrl';
import { common } from '@kit.AbilityKit';
import { AppSettings } from '../common/AppSettings';
import { NotificationService } from '../service/NotificationService';
import { TimeSlot } from '../model/TimeSlot';

@Entry
@Component
struct MainPage {
  @State currentTabIndex: number = 1;
  private controller: TabsController = new TabsController();

  @Provide('weeklyCourseVM') weeklyCourseVM: WeeklyCourseViewModel = new WeeklyCourseViewModel();
  @Provide('todayScheduleVM') todayScheduleVM: TodayScheduleViewModel = new TodayScheduleViewModel();
  @Provide('settingsVM') settingsVM: SettingsViewModel = new SettingsViewModel();

  @Watch('onAdvanceMinutesChange')
  @StorageLink(AppSettings.ADVANCE_MINUTES_KEY) advanceMinutes: number = 5;

  private periodTimeMap: Map<string, TimeSlot> = new Map([
    ['1', new TimeSlot('1', '08:30', '09:15')], ['2', new TimeSlot('2', '09:20', '10:05')],
    ['3', new TimeSlot('3', '10:25', '11:10')], ['4', new TimeSlot('4', '11:15', '12:00')],
    ['5', new TimeSlot('5', '14:00', '14:45')], ['6', new TimeSlot('6', '14:50', '15:35')],
    ['7', new TimeSlot('7', '15:55', '16:40')], ['8', new TimeSlot('8', '16:45', '17:30')],
    ['9', new TimeSlot('9', '19:00', '19:45')], ['10', new TimeSlot('10', '19:50', '20:35')]
  ]);

  onAdvanceMinutesChange(): void {
    console.log(`[MainPage] Notification setting changed to ${this.advanceMinutes} minutes. Rescheduling...`);
    this.scheduleTodayNotifications();
  }

  /**
   * â˜…â˜…â˜… æ ¸å¿ƒä¿®æ­£ #1ï¼šå°† aboutToAppear å£°æ˜ä¸º async å‡½æ•° â˜…â˜…â˜…
   * è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åœ¨å‡½æ•°å†…éƒ¨ä½¿ç”¨ await æ¥ç­‰å¾…å¼‚æ­¥æ“ä½œå®Œæˆ
   */
  async aboutToAppear() {
    console.log('[MainPage] Appearing. Initializing permissions and notifications.');

    // â˜…â˜…â˜… æ ¸å¿ƒä¿®æ­£ #2ï¼šç­‰å¾…æƒé™è¯·æ±‚å®Œæˆåï¼Œå†å†³å®šæ˜¯å¦æ‰§è¡Œä¸‹ä¸€æ­¥ â˜…â˜…â˜…
    const hasPermission = await this.requestNotificationPermission(getContext(this) as common.UIAbilityContext);

    if (hasPermission) {
      console.log('[MainPage] Permission granted. Proceeding to schedule notifications.');
      this.scheduleTodayNotifications();
    } else {
      console.log('[MainPage] Permission denied. Skipping notification scheduling.');
    }
  }

  async scheduleTodayNotifications() {
    const context = getContext(this) as common.UIAbilityContext;
    console.log('[MainPage] Running notification scheduling...');
    await NotificationService.cancelAllReminders();
    const courses: TodayCourseResponse[] = await this.todayScheduleVM.loadTodayCourses();
    if (!courses || courses.length === 0) {
      console.log('[MainPage] No courses for today. Skipping notification scheduling.');
      return;
    }
    console.log(`[MainPage] Found ${courses.length} courses. Scheduling with ${this.advanceMinutes} minutes advance.`);
    for (const course of courses) {
      const timeSlot = this.periodTimeMap.get(course.startPeriod.toString());
      if (!timeSlot) continue;
      const now = new Date();
      const timeParts = timeSlot.startTime.split(':').map(Number);
      const courseStartTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), timeParts[0], timeParts[1]);
      try {
        await NotificationService.scheduleCourseNotification(course.name, courseStartTime, this.advanceMinutes, context);
      } catch (e) {
        const error = e as Error;
        console.error(`[MainPage] Failed to schedule for course: ${course.name}. Reason: ${error.message}`);
      }
    }
  }

  /**
   * â˜…â˜…â˜… æ ¸å¿ƒä¿®æ­£ #3ï¼šè®©å‡½æ•°è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œå‘Šè¯‰è°ƒç”¨è€…æƒé™æ˜¯å¦æˆåŠŸè·å– â˜…â˜…â˜…
   */
  async requestNotificationPermission(context: common.UIAbilityContext): Promise<boolean> {
    try {
      let atManager = abilityAccessCtrl.createAtManager();
      const permissions: Array<Permissions> = ['ohos.permission.PUBLISH_AGENT_REMINDER'];
      // requestPermissionsFromUser ä¼šç­‰å¾…ç”¨æˆ·ç‚¹å‡»å¼¹çª—
      const result = await atManager.requestPermissionsFromUser(context, permissions);
      // æ£€æŸ¥æˆæƒç»“æœï¼Œå¦‚æœæ‰€æœ‰æƒé™éƒ½è¢«æˆäºˆï¼ˆgrantStatuséƒ½ä¸º0ï¼‰ï¼Œåˆ™è®¤ä¸ºæˆåŠŸ
      const allGranted = result.authResults.every(status => status === 0);
      if (!allGranted) {
        console.warn('Not all reminder permissions were granted by the user.');
        return false;
      }

      let isEnabled = await notificationManager.isNotificationEnabled();
      if (!isEnabled) {
        // å¼•å¯¼ç”¨æˆ·å¼€å¯ï¼Œä½†è¿™é‡Œæˆ‘ä»¬æ— æ³•å¾—çŸ¥ç”¨æˆ·æœ€ç»ˆæ˜¯å¦å¼€å¯ï¼Œæš‚æ—¶å‡è®¾ä»–ä¼šå¼€å¯
        await notificationManager.requestEnableNotification();
      }
      return true; // æ‰€æœ‰æµç¨‹èµ°å®Œï¼Œè¿”å›æˆåŠŸ
    } catch (error) {
      const err = error as BusinessError;
      console.error(`Failed to request permission. Code: ${err.code}, message: ${err.message}`);
      return false; // å‘ç”Ÿä»»ä½•é”™è¯¯éƒ½è¿”å›å¤±è´¥
    }
  }

  build() {
    Tabs({ barPosition: BarPosition.End, controller: this.controller }) {
      TabContent() { TodaySchedule() }.tabBar(this.TabBuilder('ä»Šæ—¥', 0, 'ğŸ“š'))
      TabContent() { Index() }.tabBar(this.TabBuilder('è¯¾ç¨‹è¡¨', 1, 'ğŸ“…'))
      TabContent() { Settings() }.tabBar(this.TabBuilder('è®¾ç½®', 2, 'âš™ï¸'))
    }
    .onChange((index: number) => { this.currentTabIndex = index; })
    .barWidth('100%').barHeight(60).backgroundColor('#F1F3F5').animationDuration(200)
  }

  @Builder TabBuilder(title: string, index: number, icon: string) {
    Column({ space: 4 }) {
      Text(icon).fontSize(24)
      Text(title).fontSize(12).fontColor(this.currentTabIndex === index ? '#007DFF' : '#666666')
    }
    .width('100%').height('100%').justifyContent(FlexAlign.Center)
  }
}